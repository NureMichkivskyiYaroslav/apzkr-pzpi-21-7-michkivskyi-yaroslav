1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

Система в цілому має класичну клієнт-серверну архітектуру. Сервери функціонують незалежно один від одного. Клієнти також працюють паралельно і автономно. Жорсткої прив'язки клієнтів до серверів немає. У системі використовуються три різних сервери:
1.	основний сервер системи, який є приймачем для запитів REST API, здійснює обробку даних та бізнес-логіку, комунікує з ODM для взаємодії з сервером бази даних;
2.	сервер бази даних приймає дані від основного серверу системи та зберігає їх локально, забезпечуючи безпеку даних;
3.	сервер веб додатку, який формує сторінки для відправки їх у браузер користувача.
Таким чином, можна сказати, що система використовує трирівневу архітектурну модель програмного забезпечення, забезпечуючи незалежність кожного компонента, що в результаті покращує можливості горизонтального масштабування, швидкодію та доступність системи в цілому.

2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

Було розроблено діаграму системи у вигляді UML діаграми розгортання (рис 2.1).
Система складається з 6 вузлів: сервер системи, сервер веб-додатку, браузер адміністратора, смартфон клієнта, IoT пристрій, сервер бази даних. На сервері системи відбувається бізнес логіка та взаємодія з базою даних (за допомогою протоколу TCP/IP та ODM Mongoose). На сервері веб-додатку знаходиться створення макету веб-сторінки. У браузері адміністратора відкривається створена веб-сторінка, зберігається дані акаунту та надсилаються HTTP запити на сервер. У смартфоні клієнта застосунок також відкриває створену веб-сторінку, зберігає дані акаунту та надсилає HTTP запити на сервер. IoT Device представляє собою датчики температури, які періодично надсилають запити з показами на System Server. Сервер бази даних зберігає дані.

3 ОПИС АРХІТЕКТУРИ СЕРВЕРНОЇ ЧАСТИНИ

Архітектура серверної частини програмної системи базується на звичайному проєкті на ExpressJS, тобто має трирівневу структуру: маршрути, контролери/сервіси та Mongoose ODM. Система складається з п’яти основних компонентів:
1.	маршрути (routers): використовуються для направлення отриманих на сервер запитів до відповідних контролерів. Також вони використовують проміжне програмне забезпечення, необхідне для подальшої обробки запиту у контролері;
2.	контролери (controllers): обробляють запити, отримані сервером. У цій системі вони взаємодіють з моделями для внесення змін у базу даних, а також використовують сервіси для реалізації складнішої бізнес-логіки. Контролери отримують параметри, рядок запиту чи тіло запиту;
3.	проміжне програмне забезпечення (middlewares): застосовується для перевірки авторизації користувача та перевірки, чи має він доступ до відповідних точок системи згідно своєї ролі. Також використовується для розшифровки імені користувача з JWT токену та передачі його далі до контролера;
4.	моделі (models): відповідають за ініціалізацію бази даних та подальшу взаємодію з нею. За це відповідає ODM Mongoose разом з базою даних MongoDB. До моделей можна звертатися з будь-якої частини системи, що спрощує їх використання. Моделі також підтримують складні сценарії, такі як створення об’єктів та валідація даних;
5.	сервіси (services): використовується для проведення складніших розрахунків, або винесення з контролерів функціоналу, який повторюється. В системі наявні сервіс для створення статистики порушень температури перевезень та сервіс створення jwt токенів.

4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Програмна система “ColdTrip” має 2 ролі користувачів: адміністратор(Admin) та клієнт(Client).
Взаємодію користувачів з програмною системою представлено на діаграмі прецедентів (рис. 4.1). За діаграмою ми визначили необхідну функціональність та взаємодію користувачів з системою.

5 ПОБУДОВА ER-ДІАГРАМИ

Проектування бази даних було проведено за допомогою створення ER-моделі даних (рис 5.1). Діаграма складається з 9 таблиць: готель, кімната, клієнт готелю, тип приладу, прилад, сесія клієнта, показники загального лічильника, сесія приладу, показники лічильника приладу.
База даних має такі зв’язки  між сутностями:
1.	водій – перевезення(один до багатьох, у водія може бути багато перевезень, або жодного, перевезення виконується одним водієм);
2.	рефрижератор – перевезення(один до багатьох, рефрижератор може бути використаний у багатьох або жодному з перевезень, перевезення здійснює рівно один рефрижератор);
3.	клієнт – перевезення(один до багатьох, клієнт може мати багато або жодного перевезення, перевезення має рівно одного замовника)
4.	перевезення – упаковка у перевезенні(один до багатьох, упаковок у перевезенні може бути багато, але всі вони належать рівно одному перевезенню);
5.	упаковка – упаковка у перевезенні(один до багатьох, упаковки у перевезенні – сутності що посилаються рівно на одну упаковку, але їх може бути багато або жодної для конкретної упаковки);
6.	упаковка у перевезенні – показники датчиків температури(один до багатьох, для упаковки у перевезенні може зберігатися багато або жодного показника датчиків температури, та усі показники відносяться до рівно одної упаковки у перевезенні);
Програмна система як базу даних буде використовувати MongoDB. Забезпечувати роботу з базою даних буде ODM Mongoose.

6 СПЕЦИФІКАЦІЯ REST

Програмна система використовує REST для взаємодії клієнтів із сервером. API включає 36 кінцевих точок, розподілених по 7 маршрутах (Додаток А). Кінцеві точки відповідають за передачу даних між сервером і клієнтом, направляючи вхідні дані до відповідних функцій на сервері. На серверній стороні для цього використовується стандартна маршрутизація в ExpressJS із створенням маршрутів (Route) та обробкою відповідних запитів.
Запити з маршрутів передаються до контролерів, де відбувається обробка вхідних даних. Деякі кінцеві точки не приймають жодних вхідних даних, наприклад, запит GET на “/drivers/all”, який повертає всіх водіїв. Інші кінцеві точки приймають параметри тіла запиту, як у випадку з POST-запитом на “/client/login/”, який потребує двох рядків: “username” та “password”. Більшість кінцевих точок використовують jwt токен для перевірки прав доступу до системи.

7 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ

Для проєктування внутрішньої взаємодії компонентів системи було розроблено діаграму компонентів (рис. 7.1). Система серверу складається з таких компонентів: Моделі сутності (Models), Контролери (Controller), Сервіси (Services), Проміжне ПЗ (Middlewares),  Маршрутизатори (Routers), Сервер API (APIServer). Зовнішніми компонентами є База даних (Database), Клієнтський інтерфейс (Client) та Кластер сховищ (IoT Device).

ВИСНОВКИ

У ході виконання лабораторної роботи були покращені навички з проектування серверної частини програмної системи, розробки діаграм, проектуванні бази даних. Спочатку було розроблено опис архітектури системи та серверної частини. Потім було побудовано діаграму розгортання, діаграму прецедентів, ER-діаграму та діаграму компонентів. Була розроблена програмна реалізація серверної частини програмної системи. В результаті було написано специфікацію REST для взаємодії з сервером. При розробці продукту дотримувались вимоги до чистого коду та Code Convention мови програмування JavaScript – JavaScript Standart Style.

ДОДАТОК А
Специфікація REST

Таблиця А.1 – Специфікація REST API
Посилання на кінцеву точку	Метод HTTP	Необхідна роль	Опис роботи
Маршрут Admin (“/admin/”)
/admin/register/	POST		Реєстрація адміністратора
/admin/login/	POST		Авторизація адміністратора
/admin/export/	GET	Admin	Експорт бази даних системи до json файлу
/admin/import/	GET	Admin	Імпорт бази даних системи з раніше експортованих даних
Маршрут Client (“/client/”)
/client/register/	POST		Реєстрація клієнта
/client/login/	POST		Авторизація клієнта
/client/all/	GET	Admin	Отримання усіх клієнтів
/client/:id/	GET	Admin	Отримання інформації про конкретного клієнта
Маршрут Driver (“/staff/”)
/driver/add/	POST	Admin	Додати водія
/driver/:id/	GET	Admin	Отримати повну інформацію про водія
/driver/all/	GET	Admin	Отримати інформацію про усіх водіїв
/driver/:id/edit/	PATCH	Admin	Виправити інформацію про водія
/driver/:id/delete/	DELETE	Admin	Видалити водія
Маршрут Case (“/case/”)
/case/add/	POST	Admin	Додати упаковку
/case/:id/	GET	Admin	Повна інформація про упаковку
/case/:id/edit/	PATCH	Admin	Редагування інформації про упаковку
/case/:id/delete/	DELETE	Admin	Видалити упаковку
/case/all/	GET	Admin	Отримати інформацію про усі упаковки
Маршрут Fridge (“/fridge/”)
/fridge/add/	POST	Admin	Додати рефрижератор
/fridge/all/	GET	Admin	Отримати інформацію про усі рефрижератори
/fridge/:id/	GET	Admin	Отримати повну інформацію про рефрижератор
/fridge/:id/edit/	PATCH	Admin	Редагувати інформацію про рефрижератор
/fridge/:id/relocate/	PATCH	Admin	Змінити дані про місцеположення рефрижератора
/fridge/:id/nearest/	GET	Admin	Знайти найближчий незайнятий рефрижератор
/fridge/:id/delete/	DELETE	Admin	Видалити рефрижератор
Маршрут Trip (“/trip/”)
/trip/add/	POST	Admin	Додати перевезення
/trip/client/	GET	Client	Отримати усі перевезення клієнта
/trip/client/:id/	GET	Client	Отримати повну інформацію про перевезення клієнта
/trip/all/	GET	Admin	Отримати інформацію про усі перевезення
/trip/:id/	GET	Admin	Отримати повну інформацію про конкретне перевезення
/trip/:id/finish/	PATCH	Admin	Завершити конкретне перевезення
/trip/resources/	GET	Admin	Отримати доступні ресурси що готові до перевезення
Маршрут TripCase (“/tripcase/”)
/tripcase/add/	POST	Admin	Додати упаковку у перевезення
/tripcase/:id/	GET	Admin	Отримати повну інформацію про упаковку у перевезенні
/tripcase/client/:id/	GET	Client	Отримати повну інформацію про упаковку у перевезенні
/tripcase/ti/add	POST		Додати показники датчиків температури
